#!/usr/bin/env python

'''Pipe in the output of "svnadmin dump" and get out a human readable
summary of changes at the SVN filesystem level, without diffs or log
messages.
'''
import sys

def chop(s, prefix):
    return s[len(prefix):].rstrip() if s.startswith(prefix) else None

# Thanks to http://stackoverflow.com/a/9114923/125349
def common_prefix(a,b):
    return  a[:([x[0]==x[1] for x in zip(a,b)]+[0]).index(0)]

def accum_prefix(accum, s):
    return s if accum is None else common_prefix(accum,s)

def max(a, b):
    return b if a < b else a

class Revision(object):
    def __init__(self, **kw):
        for k,v in kw.items():
            setattr(self, k, v)
        self.paths = {}
        self.node_info = None

    def format_node_path(self, key):
        path = self.node_info.get(key)
        if not path:
            return None
        kind = self.node_info.get('kind')
        fmt = '/%s'
        if kind is None:
            # strangely, deletions often appear to be missing a Node-kind field.
            fmt = '/%s </?>'
        elif kind == 'file':
            assert not path.endswith('/')
        else:
            assert kind == 'dir'
            if not path.endswith('/'):
                fmt = '/%s/'
        return fmt % path

    def open_node(self, path):
        assert self.node_info is None, "failed to close open node"
        self.node_info = dict(path=path)
        
    def close_node(self):
        if self.node_info is None:
            return

        # print '## closing node in rev', self.revnum, self.node_info
        sys.stdout.flush()
        action = self.node_info['action']
        dst_path = self.format_node_path('path')

        # is this actually a copy?
        src_path = self.format_node_path('copyfrom-path')
        if src_path:
            assert action == 'add'
            src_rev = self.node_info['copyfrom-rev']

            self.paths.setdefault(src_path,[]).append(
                dict(act='cp', src=src_path, rev=src_rev, tgt=dst_path)
            )
        else:
            path_info = self.paths.setdefault(dst_path,[])
            if action == 'delete' and len(path_info) != 0 and path_info[-1]['act'] == 'cp':
                path_info[-1]['act'] = 'mv'
            else:
                path_info.append(
                    dict(
                        act=dict(add=' +', delete=' -', change=' ~', replace='-+')[action],
                        tgt=dst_path)
                )
        self.node_info = None

    def scan(self):
        '''Return a tuple containing:
         - the longest common prefix of all target paths
         - the longest common prefix of all source paths (or None)
         - the single source revision number involved
         - the maximum length of all target paths
        '''
        tgt_prefix = None
        src_prefix = None
        common_revnum = None
        tgt_max_length = 0

        for actions in self.paths.values():
            for a in actions:
                tgt = a['tgt']
                tgt_max_length = max(tgt_max_length, len(tgt))
                tgt_prefix = accum_prefix(tgt_prefix, tgt)
                if a.get('src'):
                    src_prefix = accum_prefix(src_prefix, a['src'])
                if a.get('rev'):
                    common_revnum = (
                        a['rev'] if common_revnum is None or common_revnum == a['rev']
                        else -1)

        # Truncate source and target prefixes on directory boundaries
        tgt_prefix = tgt_prefix[:tgt_prefix.rfind('/')+1]
        if src_prefix is not None:
            src_prefix = src_prefix[:src_prefix.rfind('/')+1]
        return tgt_prefix,src_prefix,common_revnum,tgt_max_length

    def summarize(self):
        self.close_node()
        if len(self.paths) > 0:
            
            tgt_prefix,src_prefix,common_revnum,tgt_max_length = self.scan()

            print 'r' + self.revnum, (tgt_prefix,src_prefix,common_revnum)

            for p in sorted(self.paths.keys()):
                actions = self.paths[p]
                if len(actions) == 1:
                    print '  %s' % actions[0]
                else:
                    print '  ['
                    for x in actions:
                        print '    %s' % x
                    print '  ]'

def run():
    lines = iter(sys.stdin)
    last_rev = Revision()
    state = 'after-blank'
    follows_blank = False
    for line in lines:
        # print '#', state, repr(line[:60].rstrip())
        if line == '\n': 
            last_rev.close_node()
            state = 'after-blank'
        elif state == 'seek-blank':
            continue
        elif state == 'after-blank':
            revnum = chop(line, 'Revision-number: ')
            if revnum:
                last_rev.summarize()
                last_rev = Revision(revnum=revnum)
                state = 'seek-blank'
            else:
                path = chop(line, 'Node-path: ')
                if path:
                    last_rev.open_node(path)
                    state = 'in-node'
                else:
                    state = 'seek-blank'

        elif state == 'in-node':
            node_rest = chop(line, 'Node-')
            if node_rest:
                k,v = node_rest.split(': ', 1)
                # print '# *', k, '=', v
                last_rev.node_info[k] = v
            else:
                state = 'seek-blank'
        else:
            assert(not 'known state')

    last_rev.summarize()
            
if __name__ == '__main__':
    run()
